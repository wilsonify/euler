import itertools
from fractions import Fraction

# The generating function u(n) is a polynomial of degree 10.
# OP(k, n) is a polynomial of degree at most k-1, which can be obtained
# by the Lagrange interpolating polynomial (or other methods).
# Any polynomial P(n) of degree k has at most k roots (i.e. points where P(n) = 0).
# The zero polynomial Z(n) = 0 has negative infinite degree, and has roots everywhere.
# Now, let E(n) = u(n) - OP(k, n), which is also a polynomial.
#
# If k <= 10, then OP(k, n) has degree less than k <= 10, so E(n) has degree 10. So E(n) has at most 10 roots.
# By construction, OP(k, n) = u(n) for n = 1, 2, ..., k, thus E(n) already has k roots at {1, 2, ..., k}.
# E(n) has at most 10 - k roots remaining, hence among the 11 - k values {k+1, k+2, ..., 11},
# there must be an n where E(n) != 0 (i.e. an incorrect term where OP(k, n) != u(n)).
#
# If k > 10, E(n) has k roots at {1, 2, ..., k}, and possibly others.
# So either E(n) has degree at least k, or it's the zero polynomial.
# Now, u(n) has degree 10 and OP(k, n) has degree at most k-1,
# so their difference E(n) has at most degree max(10, k-1) = k-1.
# This means E(n) does not have degree k, so it is the zero polynomial.
# Hence u(n) = OP(k, n), and there are no incorrect terms.
#
# In conclusion, BOPs exist for and only for 1 <= k <= 10. For each k in that range,
# the first incorrect term (FIT) of OP(k, n) exists for some n in {k+1, k+2, ..., 11}.
DEGREE = 10


def problem101():
    """


    If we are presented with the first k terms of a sequence it is impossible
       to say with certainty the value of the next term, as there are infinitely
       many polynomial functions that can model the sequence.

       As an example, let us consider the sequence of cube numbers. This is
       defined by the generating function,
       u[n] = n^3: 1, 8, 27, 64, 125, 216, ...

       Suppose we were only given the first two terms of this sequence. Working
       on the principle that "simple is best" we should assume a linear
       relationship and predict the next term to be 15 (common difference 7).
       Even if we were presented with the first three terms, by the same
       principle of simplicity, a quadratic relationship should be assumed.

       We shall define OP(k, n) to be the n^th term of the optimum polynomial
       generating function for the first k terms of a sequence. It should be
       clear that OP(k, n) will accurately generate the terms of the sequence for
       n ≤ k, and potentially the first incorrect term (FIT) will be OP(k, k+1);
       in which case we shall call it a bad OP (BOP).

       As a basis, if we were only given the first term of sequence, it would be
       most sensible to assume constancy; that is, for n ≥ 2, OP(1, n) = u[1].

       Hence we obtain the following OPs for the cubic sequence:

       OP(1, n) = 1               1, 1, 1, 1, ...
       OP(2, n) = 7n−6            1, 8, 15, ...
       OP(3, n) = 6n^2−11n+6      1, 8, 27, 58, ...
       OP(4, n) = n^3             1, 8, 27, 64, 125, ...

       Clearly no BOPs exist for k ≥ 4.

       By considering the sum of FITs generated by the BOPs (indicated in red
       above), we obtain 1 + 15 + 58 = 74.

       Consider the following tenth degree polynomial generating function:

          u[n] = 1 − n + n^2 − n^3 + n^4 − n^5 + n^6 − n^7 + n^8 − n^9 + n^10

       Find the sum of FITs for the BOPs.
    """
    ans = Fraction(0, 1)
    for k in range(1, DEGREE + 1):
        for n in itertools.count(k + 1):
            if n == DEGREE + 2:
                raise AssertionError()
            reference = Fraction(generating_function(n), 1)
            term = optimum_polynomial(k, n)
            if term != reference:
                ans += term
                break
    return int(
        ans.numerator
        + ("" if str(ans.denominator) == 1 else "/" + str(ans.denominator))
    )


def optimum_polynomial(k, n):
    # Lagrange interpolation
    summation = Fraction(0, 1)
    for i in range(k + 1):
        product = Fraction(generating_function(i), 1)
        for j in range(1, k + 1):
            if j != i:
                product *= Fraction(n - j, i - j)
        summation += product
    return summation


def generating_function(n):
    return sum((-n) ** i for i in range(DEGREE + 1))


if __name__ == "__main__":
    print(problem101())
